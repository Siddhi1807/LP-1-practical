/*
Problem Statement 1: Two-Pass Assembler
Design suitable Data structures and implement Pass-I and Pass-II of a two-pass assembler for pseudo-machine.
Implementation should consist of a few instructions from each category and few assembler directives.
The output of Pass-I (intermediate code file and symbol table) should be input for Pass-II.

SOURCE.ASM COPY THIS AND SAVE FILE TO Source.asm


START 100
LOOP LDA ALPHA
STA BETA
ADD GAMMA
ALPHA DC 5
BETA DS 1
GAMMA DC 10
END

*/
import java.io.*;
import java.util.*;

class Symbol {
    String name;
    int address;
    boolean isDefined;

    Symbol(String name, int address, boolean defined) {
        this.name = name;
        this.address = address;
        this.isDefined = defined;
    }
}

public class TwoPassAssembler {

    private static final Map<String, String[]> OP_TABLE = new HashMap<>();
    static {
        OP_TABLE.put("LDA", new String[]{"IS", "01"});
        OP_TABLE.put("STA", new String[]{"IS", "02"});
        OP_TABLE.put("ADD", new String[]{"IS", "03"});
        OP_TABLE.put("SUB", new String[]{"IS", "04"});
        OP_TABLE.put("MOV", new String[]{"IS", "07"});
        OP_TABLE.put("START", new String[]{"AD", "01"});
        OP_TABLE.put("END", new String[]{"AD", "02"});
        OP_TABLE.put("DC", new String[]{"DL", "01"});
        OP_TABLE.put("DS", new String[]{"DL", "02"});
    }

    private static final Map<String, Symbol> SYMBOL_TABLE = new LinkedHashMap<>();
    private static List<String> INTERMEDIATE = new ArrayList<>();
    private static int LOC_COUNTER = 0;

    private static int getOrCreateSymbolIndex(String name) {
        if (!SYMBOL_TABLE.containsKey(name)) {
            SYMBOL_TABLE.put(name, new Symbol(name, -1, false));
        }
        int idx = 1;
        for (String key : SYMBOL_TABLE.keySet()) {
            if (key.equals(name)) break;
            idx++;
        }
        return idx;
    }

    public static void pass1(String sourceFile, String interFile, String symFile) throws IOException {
        try (BufferedReader br = new BufferedReader(new FileReader(sourceFile));
             BufferedWriter interWriter = new BufferedWriter(new FileWriter(interFile));
             BufferedWriter symWriter = new BufferedWriter(new FileWriter(symFile))) {

            String line;
            LOC_COUNTER = 0;

            while ((line = br.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty() || line.startsWith(";")) continue;

                String[] tokens = line.split("\\s+");
                String label = null, opcode = null, operand = null;

                int i = 0;

                if (tokens.length > 0 && tokens[0].endsWith(":")) {
                    label = tokens[0].substring(0, tokens[0].length() - 1);
                    i = 1;
                } else if (tokens.length > 1 && !OP_TABLE.containsKey(tokens[0])) {
                    label = tokens[0];
                    i = 1;
                }

                if (i < tokens.length) opcode = tokens[i++];
                if (i < tokens.length) operand = tokens[i];


                if (label != null && !label.isEmpty()) {
                    if (SYMBOL_TABLE.containsKey(label)) {
                        Symbol existingSym = SYMBOL_TABLE.get(label);
                        if (existingSym.isDefined) {
                            System.err.println("Error: Duplicate definition of symbol '" + label + "' at LC " + LOC_COUNTER);
                        } else {
                            existingSym.address = LOC_COUNTER;
                            existingSym.isDefined = true;
                        }
                    } else {
                        SYMBOL_TABLE.put(label, new Symbol(label, LOC_COUNTER, true));
                    }
                }


                if (opcode == null || !OP_TABLE.containsKey(opcode)) {
                    System.err.println("Error: Invalid/missing opcode in line: " + line);
                    continue;
                }

                String[] opInfo = OP_TABLE.get(opcode);
                String cls = opInfo[0];
                String opc = opInfo[1];

                switch (cls) {
                    case "AD":
                        if ("START".equals(opcode)) {
                            LOC_COUNTER = (operand != null) ? Integer.parseInt(operand) : 0;
                            INTERMEDIATE.add(String.format("%03d (AD,01) (C,%s)", LOC_COUNTER, operand));
                        } else if ("END".equals(opcode)) {
                            INTERMEDIATE.add("(AD,02)");
                        }
                        break;

                    case "IS":
                        String operandCode = "-";
                        if (operand != null) {
                            if (operand.matches("\\d+")) {
                                operandCode = "(C," + operand + ")";
                            } else {
                                int symIdx = getOrCreateSymbolIndex(operand);
                                operandCode = "(S," + symIdx + ")";
                            }
                        }
                        INTERMEDIATE.add(String.format("%03d (IS,%s) %s", LOC_COUNTER, opc, operandCode));
                        LOC_COUNTER++;
                        break;

                    case "DL":
                        if ("DC".equals(opcode)) {
                            INTERMEDIATE.add(String.format("%03d (DL,01) (C,%s)", LOC_COUNTER, operand));
                            LOC_COUNTER++;
                        } else if ("DS".equals(opcode)) {
                            int size = Integer.parseInt(operand);
                            INTERMEDIATE.add(String.format("%03d (DL,02) (C,%s)", LOC_COUNTER, operand));
                            LOC_COUNTER += size;
                        }
                        break;
                }
            }

            for (String ic : INTERMEDIATE) {
                interWriter.write(ic);
                interWriter.newLine();
            }

            symWriter.write("Index\tSymbol\tAddress\tDefined\n");
            int idx = 1;
            for (Symbol sym : SYMBOL_TABLE.values()) {
                symWriter.write(String.format("%d\t%s\t%d\t%s\n",
                    idx++, sym.name, sym.address, sym.isDefined ? "YES" : "NO"));
            }
        }
    }

    public static void pass2(String interFile, String symFile, String machineFile) throws IOException {
        Map<Integer, Integer> symAddr = new HashMap<>();
        try (BufferedReader symReader = new BufferedReader(new FileReader(symFile))) {
            symReader.readLine();
            String line;
            int idx = 1;
            while ((line = symReader.readLine()) != null) {
                String[] parts = line.trim().split("\\s+");
                if (parts.length >= 3) {
                    int addr = Integer.parseInt(parts[2]);
                    symAddr.put(idx++, addr);
                }
            }
        }

        try (BufferedReader interReader = new BufferedReader(new FileReader(interFile));
             BufferedWriter machineWriter = new BufferedWriter(new FileWriter(machineFile))) {

            String line;
            while ((line = interReader.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty() || (line.contains("(AD,") && !line.contains("START"))) {
                    continue;
                }

                String[] parts = line.split("\\s+", 3);
                if (parts.length < 2) continue;

                String locStr = parts[0];
                String opPart = parts[1];
                String oprPart = (parts.length > 2) ? parts[2] : "-";

                String content = opPart.substring(1, opPart.length() - 1);
                String[] opInfo = content.split(",");
                String opClass = opInfo[0];
                int opcode = Integer.parseInt(opInfo[1]);

                if ("DL".equals(opClass)) {
                    if (opcode == 1) {
                        int constantValue = Integer.parseInt(
                            oprPart.substring(oprPart.indexOf(',') + 1, oprPart.length() - 1));

                        machineWriter.write(String.format("%s %03d", locStr, constantValue));
                        machineWriter.newLine();
                    }
                    continue;
                }

                int operandValue = 0;
                if (oprPart.equals("-")) {
                    operandValue = 0;
                } else if (oprPart.startsWith("(C,")) {
                    operandValue = Integer.parseInt(
                        oprPart.substring(oprPart.indexOf(',') + 1, oprPart.length() - 1));
                } else if (oprPart.startsWith("(S,")) {
                    int symIdx = Integer.parseInt(
                        oprPart.substring(oprPart.indexOf(',') + 1, oprPart.length() - 1));
                    operandValue = symAddr.getOrDefault(symIdx, 0);
                    if (operandValue == 0 && symIdx != 0) {
                        System.err.println("Warning: Undefined symbol address retrieved for index " + symIdx);
                    }
                }

                machineWriter.write(String.format("%s %02d %03d", locStr, opcode, operandValue));
                machineWriter.newLine();
            }
        }
    }

    public static void main(String[] args) {
        String source = "source.asm";
        String inter = "intermediate.ic";
        String symtab = "symtab.txt";
        String machine = "machinecode.mc";

        if (args.length >= 4) {
            source = args[0];
            inter = args[1];
            symtab = args[2];
            machine = args[3];
        }

        try {
            SYMBOL_TABLE.clear();
            INTERMEDIATE.clear();

            pass1(source, inter, symtab);
            pass2(inter, symtab, machine);

            System.out.println("Two-pass assembly completed successfully.");
            System.out.println("Intermediate: " + inter);
            System.out.println("Symbol Table: " + symtab);
            System.out.println("Machine Code: " + machine);

        } catch (Exception e) {
            System.err.println("Assembly Error: " + e.getMessage());
            e.printStackTrace();
        }
    }
}

/*
Problem Statement 2: Two-Pass Macro Processor
Design suitable data structures and implement Pass-I and Pass-II of a two-pass macroprocessor.
The output of Pass-I (MNT, MDT and intermediate code file without any macro definitions) should be input for Pass-II.


SOURCE.ASM COPY THIS AND SAVE FILE TO Source.asm


START 100
LOOP LDA ALPHA
STA BETA
ADD GAMMA
ALPHA DC 5
BETA DS 1
GAMMA DC 10
END

*/


import java.io.*;
import java.util.*;

class MNTEntry {
    String macroName;
    int mdtIndex;

    MNTEntry(String macroName, int mdtIndex) {
        this.macroName = macroName;
        this.mdtIndex = mdtIndex;
    }
}

public class TwoPassMacroProcessor {
    static List<MNTEntry> MNT = new ArrayList<>();
    static List<String> MDT = new ArrayList<>();
    static List<String> intermediateCode = new ArrayList<>();

    static void pass1(String sourceFile, String interFile, String mntFile, String mdtFile) throws IOException {
        BufferedReader br = new BufferedReader(new FileReader(sourceFile));
        BufferedWriter interWriter = new BufferedWriter(new FileWriter(interFile));
        BufferedWriter mntWriter = new BufferedWriter(new FileWriter(mntFile));
        BufferedWriter mdtWriter = new BufferedWriter(new FileWriter(mdtFile));

        String line;
        boolean inMacro = false;
        String currentMacro = null;
        int mdtIndex = 0;

        while ((line = br.readLine()) != null) {
            String trimmedLine = line.trim();
            if (trimmedLine.isEmpty()) continue;

            String[] parts = trimmedLine.split("\\s+");
            String firstWord = parts[0];

            if (firstWord.equalsIgnoreCase("MACRO")) {
                inMacro = true;
                continue; // Skip MACRO line
            }

            if (inMacro) {
                if (currentMacro == null) {

                    currentMacro = parts[0];


                    MNT.add(new MNTEntry(currentMacro, MDT.size()));


                    MDT.add(trimmedLine);

                } else if (firstWord.equalsIgnoreCase("MEND")) {

                    MDT.add("MEND");
                    inMacro = false;
                    currentMacro = null;
                } else {

                    MDT.add(trimmedLine);
                }
            } else {

                interWriter.write(trimmedLine);
                interWriter.newLine();
            }
        }


        for (MNTEntry entry : MNT) {
            mntWriter.write(entry.macroName + "\t" + entry.mdtIndex);
            mntWriter.newLine();
        }

        for (String mdtLine : MDT) {
            mdtWriter.write(mdtLine);
            mdtWriter.newLine();
        }

        br.close();
        interWriter.close();
        mntWriter.close();
        mdtWriter.close();
    }


    static void pass2(String interFile, String mntFile, String mdtFile, String outputFile) throws IOException {
        BufferedReader interReader = new BufferedReader(new FileReader(interFile));
        BufferedReader mntReader = new BufferedReader(new FileReader(mntFile));
        BufferedReader mdtReader = new BufferedReader(new FileReader(mdtFile));
        BufferedWriter outputWriter = new BufferedWriter(new FileWriter(outputFile));


        Map<String, Integer> mntMap = new HashMap<>();
        String mntLine;
        while ((mntLine = mntReader.readLine()) != null) {
            String[] parts = mntLine.trim().split("\\s+");
            mntMap.put(parts[0], Integer.parseInt(parts[1]));
        }


        List<String> mdtList = new ArrayList<>();
        String mdtLine;
        while ((mdtLine = mdtReader.readLine()) != null) {
            mdtList.add(mdtLine);
        }

        String line;
        while ((line = interReader.readLine()) != null) {
            String trimmedLine = line.trim();
            if (trimmedLine.isEmpty()) {
                outputWriter.newLine();
                continue;
            }
            String[] parts = trimmedLine.split("\\s+");
            String possibleMacro = parts[0];

            if (mntMap.containsKey(possibleMacro)) {

                int mdtIndex = mntMap.get(possibleMacro);

                while (!mdtList.get(mdtIndex).equalsIgnoreCase("MEND")) {
                    outputWriter.write(mdtList.get(mdtIndex));
                    outputWriter.newLine();
                    mdtIndex++;
                }
            } else {

                outputWriter.write(trimmedLine);
                outputWriter.newLine();
            }
        }

        interReader.close();
        mntReader.close();
        mdtReader.close();
        outputWriter.close();
    }

    public static void main(String[] args) {
        try {
            pass1("source.asm", "intermediate.asm", "mnt.txt", "mdt.txt");
            pass2("intermediate.asm", "mnt.txt", "mdt.txt", "expanded.asm");

            System.out.println("Two-pass Macro processing completed.");
            System.out.println("Intermediate code: intermediate.asm");
            System.out.println("Macro Name Table: mnt.txt");
            System.out.println("Macro Definition Table: mdt.txt");
            System.out.println("Expanded code after macro expansion: expanded.asm");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


/* 
Problem Statement 3: First Come First Serve (FCFS) CPU Scheduling
Write a program to simulate the First Come First Serve (FCFS) CPU scheduling algorithm.
The program should accept process details such as Process ID, Arrival Time, and Burst Time and compute the Waiting Time and Turnaround Time for each process. Display the Gantt chart, average waiting time, and average turnaround time.

Description:
This program simulates the FCFS CPU scheduling algorithm. It takes input for the number of processes and their respective burst times. Although the problem statement mentions arrival time, this implementation assumes all processes arrive at time zero (or in order) since arrival time handling is not fully included here. The program calculates waiting time and turnaround time for each process and prints a Gantt chart along with average waiting time and turnaround time.
*/

#include<stdio.h>
int main(){
    int i,n;
    printf("Enter the total number of processes : ");
    scanf("%d",&n);
    
    int pid[n], at[n], bt[n], ct[n], tat[n], wt[n];
    for(i=0; i<n; i++){
        printf("Enter Arrival Time and Burst Time for the proccess %d: ",i+1);
        scanf("%d%d",&at[i],&bt[i]);
        pid[i] = i+1;
    }
    
    // sort according to Arrival Time
    for(i=0; i<n-1; i++){
        for(int j=0; j<n-i-1; j++){
            if(at[j]>at[j+1]){
                int temp;
                temp = at[j]; at[j] = at[j+1]; at[j+1] = temp;
                temp = bt[j]; bt[j] = bt[j+1]; bt[j+1] = temp;
                temp = pid[j]; pid[j] = pid[j+1]; pid[j+1] = temp;
            }
        }
    }
    
    // calculate completion time
    ct[0] = at[0] + bt[0];
    for(i=1; i<n; i++){
        if(at[i]>ct[i-1]){
            ct[i] = at[i] + bt[i];  // corner case for idle CPU time
        } else {
            ct[i] = ct[i-1] + bt[i];
        }
    }
    
    // caluculate turn around time and waiting time
    float avgTAT = 0, avgWT = 0;
    for(int i=0; i<n; i++){
        tat[i] = ct[i] - at[i];
        wt[i] = tat[i] - bt[i];
        avgTAT += tat[i];
        avgWT += wt[i];
    }
    
    //print all values
    printf("\nPID\tAT\tBT\tCT\tTAT\tWT\n");
    for(i=0 ; i<n; i++){
        printf("%d\t%d\t%d\t%d\t%d\t%d\n",pid[i],at[i],bt[i],ct[i],tat[i],wt[i]);
    }
    
    // Print Gantt Chart
    printf("Gantt Chart : \n");
    for(int i=0; i<n; i++){
        printf("| P%d ",pid[i]);
    }
    printf("|\n");
    
    printf("%d",at[0]);
    for(int i=0; i<n; i++){
        printf("\t%d", ct[i]);
    }
    
    printf("\nAverage TAT is %.2f: ", avgTAT / n);
    printf("\nAverage WT is %.2f: ",avgWT / n);
    
    return 0;
    
}

/*
Problem Statement 4: Shortest Job First (SJF – Preemptive) Scheduling
Write a program to simulate the Shortest Job First (SJF – Preemptive) CPU scheduling algorithm. The program should calculate and display the order of execution, waiting time, turnaround time, and their averages for all processes.
Description:
This program simulates the SJF Preemptive scheduling algorithm where the CPU is assigned to the process with the shortest remaining burst time at every time unit. Processes with earlier arrival times and smaller burst times are prioritized. The program tracks remaining time for each process, calculates waiting and turnaround times after completion, and prints the results including average waiting and turnaround times.
*/
#include <stdio.h>
#include <limits.h>

int main() {
    int n, i, smallest, time, completed = 0;
    float avgWT = 0, avgTAT = 0;

    printf("Enter number of processes: ");
    scanf("%d", &n);

    int pid[n], at[n], bt[n], rt[n], ct[n], tat[n], wt[n];
    
    for (i = 0; i < n; i++) {
        printf("Enter Arrival Time and Burst Time for Process %d: ", i + 1);
        scanf("%d%d", &at[i], &bt[i]);
        pid[i] = i + 1;
        rt[i] = bt[i];
    }

    int currentTime = 0;
    int ganttChart[1000]; // store process IDs at each time
    int gcIndex = 0;      // track index in Gantt chart

    while (completed != n) {
        smallest = -1;
        int minRT = INT_MAX;

        // Find process with smallest remaining time among arrived ones
        for (i = 0; i < n; i++) {
            if (at[i] <= currentTime && rt[i] > 0 && rt[i] < minRT) {
                minRT = rt[i];
                smallest = i;
            }
        }

        if (smallest == -1) {
            ganttChart[gcIndex++] = -1; // CPU idle
            currentTime++;
            continue;
        }

        ganttChart[gcIndex++] = pid[smallest]; // record running process
        rt[smallest]--;
        currentTime++;

        if (rt[smallest] == 0) {
            completed++;
            ct[smallest] = currentTime;
            tat[smallest] = ct[smallest] - at[smallest];
            wt[smallest] = tat[smallest] - bt[smallest];
            avgWT += wt[smallest];
            avgTAT += tat[smallest];
        }
    }

    printf("\nPID\tAT\tBT\tCT\tTAT\tWT\n");
    for (i = 0; i < n; i++) {
        printf("%d\t%d\t%d\t%d\t%d\t%d\n", pid[i], at[i], bt[i], ct[i], tat[i], wt[i]);
    }

    printf("\nAverage Turnaround Time = %.2f", avgTAT / n);
    printf("\nAverage Waiting Time = %.2f\n", avgWT / n);

    // -------------------- GANTT CHART DISPLAY --------------------
    printf("\n\nGANTT CHART:\n");
    printf("-------------------------------------------------\n");

    // Print process sequence
    for (i = 0; i < gcIndex; i++) {
        if (ganttChart[i] == -1)
            printf("| Idle ");
        else
            printf("| P%d ", ganttChart[i]);
    }
    printf("|\n");

    // Print timeline
    printf("0");
    for (i = 1; i <= gcIndex; i++) {
        printf("   %d", i);
    }

    printf("\n-------------------------------------------------\n");

    return 0;
}

/*
Problem Statement 5: Priority Scheduling (Non-Preemptive)
Write a program to simulate the Priority Scheduling (Non-Preemptive) algorithm.
Each process should have an associated priority value, and the scheduler should select the process with the highest priority for execution next.
Compute and display the waiting time, turnaround time, and average times for all processes.
*/
#include <stdio.h>
#include <limits.h>

int main() {
    int n, i, j;
    float avgTAT = 0, avgWT = 0;

    printf("Enter total number of processes: ");
    scanf("%d", &n);

    int pid[n], at[n], bt[n], pr[n], ct[n], tat[n], wt[n];

    for (i = 0; i < n; i++) {
        printf("Enter Arrival Time, Burst Time, and Priority for Process %d: ", i + 1);
        scanf("%d%d%d", &at[i], &bt[i], &pr[i]);
        pid[i] = i + 1;
    }

    // Sort by arrival time
    for (i = 0; i < n - 1; i++) {
        for (j = 0; j < n - i - 1; j++) {
            if (at[j] > at[j + 1]) {
                int temp;
                temp = at[j]; at[j] = at[j + 1]; at[j + 1] = temp;
                temp = bt[j]; bt[j] = bt[j + 1]; bt[j + 1] = temp;
                temp = pr[j]; pr[j] = pr[j + 1]; pr[j + 1] = temp;
                temp = pid[j]; pid[j] = pid[j + 1]; pid[j + 1] = temp;
            }
        }
    }

    int completed = 0, currentTime = 0;
    int done[n];
    for (i = 0; i < n; i++) done[i] = 0;

    // Arrays for Gantt Chart
    int gcPID[1000], start[1000], end[1000];
    int gcIndex = 0;

    while (completed != n) {
        int smallest = -1;
        int minPR = INT_MAX;

        // Find process with highest priority among arrived ones
        for (i = 0; i < n; i++) {
            if (at[i] <= currentTime && done[i] == 0 && pr[i] < minPR) {
                smallest = i;
                minPR = pr[i];
            }
        }

        // If CPU is idle
        if (smallest == -1) {
            currentTime++;
            continue;
        }

        // Record in Gantt chart
        gcPID[gcIndex] = pid[smallest];
        start[gcIndex] = currentTime;

        currentTime += bt[smallest];  // Execute the process fully (non-preemptive)
        end[gcIndex] = currentTime;
        gcIndex++;

        ct[smallest] = currentTime;
        tat[smallest] = ct[smallest] - at[smallest];
        wt[smallest] = tat[smallest] - bt[smallest];

        avgTAT += tat[smallest];
        avgWT += wt[smallest];

        done[smallest] = 1;
        completed++;
    }

    // Print results
    printf("\nPID\tAT\tBT\tPR\tCT\tTAT\tWT\n");
    for (i = 0; i < n; i++) {
        printf("%d\t%d\t%d\t%d\t%d\t%d\t%d\n",
               pid[i], at[i], bt[i], pr[i], ct[i], tat[i], wt[i]);
    }

    printf("\nAverage Turnaround Time = %.2f", avgTAT / n);
    printf("\nAverage Waiting Time = %.2f\n", avgWT / n);

    // Print Gantt Chart
    printf("\n\nGANTT CHART:\n");
    printf("-------------------------------------------------\n");

    for (i = 0; i < gcIndex; i++) {
        printf("|  P%d  ", gcPID[i]);
    }
    printf("|\n");

    printf("-------------------------------------------------\n");
    printf("%d", start[0]);
    for (i = 0; i < gcIndex; i++) {
        printf("     %d", end[i]);
    }
    printf("\n");

    return 0;
}
/*
Problem Statement 6: Round Robin (RR) Scheduling
Write a program to simulate the Round Robin (Preemptive) CPU scheduling algorithm.
The program should take time quantum as input and schedule processes in a cyclic order.
Display the Gantt chart, waiting time, turnaround time, and average values for all processes.
*/
#include <stdio.h>

int main() {
    int n, tq, i;
    float avgWT = 0, avgTAT = 0;

    printf("Enter number of processes: ");
    scanf("%d", &n);

    int pid[n], at[n], bt[n], rt[n], ct[n], tat[n], wt[n];

    // Input process details
    for (i = 0; i < n; i++) {
        printf("Enter Arrival Time and Burst Time for Process %d: ", i + 1);
        scanf("%d%d", &at[i], &bt[i]);
        pid[i] = i + 1;
        rt[i] = bt[i]; // remaining time initially = burst time
    }

    printf("Enter Time Quantum: ");
    scanf("%d", &tq);

    int time = 0, completed = 0;
    int done[n];
    for (i = 0; i < n; i++) done[i] = 0;

    // Gantt chart arrays
    int gcPID[1000], start[1000], end[1000];
    int gcIndex = 0;

    // Continue until all processes are completed
    while (completed != n) {
        int executed = 0;  // to track if any process executed in this cycle

        for (i = 0; i < n; i++) {
            if (at[i] <= time && rt[i] > 0) { // process has arrived and not finished
                executed = 1;
                
                gcPID[gcIndex] = pid[i];
                start[gcIndex] = time;

                if (rt[i] <= tq) {
                    time += rt[i];
                    rt[i] = 0;
                    end[gcIndex] = time;
                    gcIndex++;

                    ct[i] = time;
                    tat[i] = ct[i] - at[i];
                    wt[i] = tat[i] - bt[i];
                    avgWT += wt[i];
                    avgTAT += tat[i];
                    completed++;
                } else {
                    rt[i] -= tq;
                    time += tq;
                    end[gcIndex] = time;
                    gcIndex++;
                }
            }
        }

        if (!executed) {
            // CPU idle
            gcPID[gcIndex] = -1; // idle marker
            start[gcIndex] = time;
            time++;
            end[gcIndex] = time;
            gcIndex++;
        }
    }

    // Display table
    printf("\nPID\tAT\tBT\tCT\tTAT\tWT\n");
    for (i = 0; i < n; i++) {
        printf("%d\t%d\t%d\t%d\t%d\t%d\n",
               pid[i], at[i], bt[i], ct[i], tat[i], wt[i]);
    }

    printf("\nAverage Turnaround Time = %.2f", avgTAT / n);
    printf("\nAverage Waiting Time = %.2f\n", avgWT / n);

    // Display Gantt Chart
    printf("\n\nGANTT CHART:\n");
    printf("-------------------------------------------------\n");
    for (i = 0; i < gcIndex; i++) {
        if (gcPID[i] == -1)
            printf("| IDLE ");
        else
            printf("| P%d ", gcPID[i]);
    }
    printf("|\n");
    printf("-------------------------------------------------\n");

    // Print timeline
    printf("%d", start[0]);
    for (i = 0; i < gcIndex; i++) {
        printf("    %d", end[i]);
    }
    printf("\n");

    return 0;
}

/*
Problem Statement 7: Memory Allocation – First Fit
Write a program to simulate First Fit memory allocation strategy.
The program should allocate each process to the first available memory block that is large enough to accommodate it.
Display the memory allocation table and identify any unused or fragmented memory.
*/
#include <stdio.h>

int main() {
    int nb, np, i, j;
    printf("Enter the number of memory blocks: ");
    scanf("%d", &nb);
    
    int blockSize[nb], blockFlag[nb];
    printf("Enter the size of each block:\n");
    for (i = 0; i < nb; i++) {
        printf("Block %d: ", i + 1);
        scanf("%d", &blockSize[i]);
        blockFlag[i] = 0; // 0 = free, 1 = allocated
    }

    printf("\nEnter the number of processes: ");
    scanf("%d", &np);
    int processSize[np], allocation[np], fragmentation[np];
    
    printf("Enter the size of each process:\n");
    for (i = 0; i < np; i++) {
        printf("Process %d: ", i + 1);
        scanf("%d", &processSize[i]);
        allocation[i] = -1; // initially not allocated
        fragmentation[i] = 0;
    }

    // First Fit Allocation Logic
    for (i = 0; i < np; i++) {
        for (j = 0; j < nb; j++) {
            if (blockFlag[j] == 0 && blockSize[j] >= processSize[i]) {
                // allocate block j to process i
                allocation[i] = j;
                blockFlag[j] = 1;
                fragmentation[i] = blockSize[j] - processSize[i];
                break; // stop after first fit
            }
        }
    }

    // Display memory allocation table
    printf("\nProcess No\tProcess Size\tBlock No\tBlock Size\tFragmentation\n");
    for (i = 0; i < np; i++) {
        if (allocation[i] != -1)
            printf("%d\t\t%d\t\t%d\t\t%d\t\t%d\n", 
                   i + 1, processSize[i], allocation[i] + 1, 
                   blockSize[allocation[i]], fragmentation[i]);
        else
            printf("%d\t\t%d\t\tNot Allocated\t-\t\t-\n", i + 1, processSize[i]);
    }

    // Display unused memory blocks
    printf("\nUnused / Free Memory Blocks:\n");
    printf("Block No\tBlock Size\n");
    int unused = 0;
    for (i = 0; i < nb; i++) {
        if (blockFlag[i] == 0) {
            printf("%d\t\t%d\n", i + 1, blockSize[i]);
            unused = 1;
        }
    }
    if (!unused)
        printf("None (All blocks allocated)\n");

    return 0;
}

/*
Problem Statement 8: Memory Allocation – Best Fit
Write a program to simulate Best Fit memory allocation strategy.
The program should allocate each process to the smallest available block that can hold it.
Display the final allocation and show internal fragmentation if any.
*/
#include <stdio.h>

int main() {
    int nb, np, i, j;
    printf("Enter the number of memory blocks: ");
    scanf("%d", &nb);
    
    int blockSize[nb], blockFlag[nb];
    printf("Enter the size of each block:\n");
    for (i = 0; i < nb; i++) {
        printf("Block %d: ", i + 1);
        scanf("%d", &blockSize[i]);
        blockFlag[i] = 0;  // 0 = free, 1 = allocated
    }
    
    printf("\nEnter the number of processes: ");
    scanf("%d", &np);
    int processSize[np], allocation[np], internalFrag[np];
    printf("Enter the size of each process:\n");
    for (i = 0; i < np; i++) {
        printf("Process %d: ", i + 1);
        scanf("%d", &processSize[i]);
        allocation[i] = -1;  // -1 means not allocated
        internalFrag[i] = 0;
    }

    // Best Fit Allocation Logic
    for (i = 0; i < np; i++) {
        int bestIdx = -1;
        for (j = 0; j < nb; j++) {
            if (blockFlag[j] == 0 && blockSize[j] >= processSize[i]) {
                if (bestIdx == -1 || blockSize[j] < blockSize[bestIdx]) {
                    bestIdx = j;  // choose smaller fitting block
                }
            }
        }

        if (bestIdx != -1) {
            allocation[i] = bestIdx;
            blockFlag[bestIdx] = 1;
            internalFrag[i] = blockSize[bestIdx] - processSize[i];
        }
    }

    // Display results
    printf("\nProcess No\tProcess Size\tBlock No\tBlock Size\tInternal Fragmentation\n");
    for (i = 0; i < np; i++) {
        if (allocation[i] != -1)
            printf("%d\t\t%d\t\t%d\t\t%d\t\t%d\n", 
                    i + 1, processSize[i], allocation[i] + 1, 
                    blockSize[allocation[i]], internalFrag[i]);
        else
            printf("%d\t\t%d\t\tNot Allocated\t-\t\t-\n", i + 1, processSize[i]);
    }

    return 0;
}

/*
Problem Statement 9: Memory Allocation – Next Fit
Write a program to simulate Next Fit memory allocation strategy.
The program should continue searching for the next suitable memory block from the last allocated position instead of starting from the beginning.
Display the memory allocation table and fragmentation details.
*/
#include <stdio.h>

int main() {
    int nb, np, i, j, last = 0;
    printf("Enter the number of memory blocks: ");
    scanf("%d", &nb);

    int blockSize[nb], blockFlag[nb];
    printf("Enter the size of each block:\n");
    for (i = 0; i < nb; i++) {
        printf("Block %d: ", i + 1);
        scanf("%d", &blockSize[i]);
        blockFlag[i] = 0; // 0 = free, 1 = allocated
    }

    printf("\nEnter the number of processes: ");
    scanf("%d", &np);
    int processSize[np], allocation[np], fragmentation[np];
    printf("Enter the size of each process:\n");
    for (i = 0; i < np; i++) {
        printf("Process %d: ", i + 1);
        scanf("%d", &processSize[i]);
        allocation[i] = -1;  // initially not allocated
        fragmentation[i] = 0;
    }

    // Next Fit Allocation Logic
    for (i = 0; i < np; i++) {
        int count = 0, allocated = 0;
        j = last;

        while (count < nb) {
            if (blockFlag[j] == 0 && blockSize[j] >= processSize[i]) {
                allocation[i] = j;
                blockFlag[j] = 1;
                fragmentation[i] = blockSize[j] - processSize[i];
                last = j; // remember the last allocated position
                allocated = 1;
                break;
            }

            j = (j + 1) % nb; // circular search
            count++;
        }

        if (!allocated)
            allocation[i] = -1; // not allocated if no block fits
    }

    // Display results
    printf("\nProcess No\tProcess Size\tBlock No\tBlock Size\tFragmentation\n");
    for (i = 0; i < np; i++) {
        if (allocation[i] != -1)
            printf("%d\t\t%d\t\t%d\t\t%d\t\t%d\n",
                   i + 1, processSize[i], allocation[i] + 1,
                   blockSize[allocation[i]], fragmentation[i]);
        else
            printf("%d\t\t%d\t\tNot Allocated\t-\t\t-\n", i + 1, processSize[i]);
    }

    // Display unused blocks
    printf("\nUnused / Free Memory Blocks:\n");
    printf("Block No\tBlock Size\n");
    int freeFlag = 0;
    for (i = 0; i < nb; i++) {
        if (blockFlag[i] == 0) {
            printf("%d\t\t%d\n", i + 1, blockSize[i]);
            freeFlag = 1;
        }
    }
    if (!freeFlag)
        printf("None (All blocks allocated)\n");

    return 0;
}

/*
Problem Statement 10: Memory Allocation – Worst Fit
Write a program to simulate Worst Fit memory allocation strategy.
The program should allocate each process to the largest available memory block.
Display the memory allocation results and any unused space.
*/

#include <stdio.h>

int main() {
    int nb, np, i, j;
    printf("Enter the number of memory blocks: ");
    scanf("%d", &nb);

    int blockSize[nb], blockFlag[nb];
    printf("Enter the size of each block:\n");
    for (i = 0; i < nb; i++) {
        printf("Block %d: ", i + 1);
        scanf("%d", &blockSize[i]);
        blockFlag[i] = 0; // 0 = free, 1 = allocated
    }

    printf("\nEnter the number of processes: ");
    scanf("%d", &np);
    int processSize[np], allocation[np], fragmentation[np];
    printf("Enter the size of each process:\n");
    for (i = 0; i < np; i++) {
        printf("Process %d: ", i + 1);
        scanf("%d", &processSize[i]);
        allocation[i] = -1;  // initially not allocated
        fragmentation[i] = 0;
    }

    // Worst Fit Allocation Logic
    for (i = 0; i < np; i++) {
        int worstIdx = -1;
        for (j = 0; j < nb; j++) {
            if (blockFlag[j] == 0 && blockSize[j] >= processSize[i]) {
                if (worstIdx == -1 || blockSize[j] > blockSize[worstIdx]) {
                    worstIdx = j;  // pick the largest suitable block
                }
            }
        }

        if (worstIdx != -1) {
            allocation[i] = worstIdx;
            blockFlag[worstIdx] = 1;
            fragmentation[i] = blockSize[worstIdx] - processSize[i];
        }
    }

    // Display results
    printf("\nProcess No\tProcess Size\tBlock No\tBlock Size\tFragmentation\n");
    for (i = 0; i < np; i++) {
        if (allocation[i] != -1)
            printf("%d\t\t%d\t\t%d\t\t%d\t\t%d\n",
                   i + 1, processSize[i], allocation[i] + 1,
                   blockSize[allocation[i]], fragmentation[i]);
        else
            printf("%d\t\t%d\t\tNot Allocated\t-\t\t-\n", i + 1, processSize[i]);
    }

    // Display unused blocks
    printf("\nUnused / Free Memory Blocks:\n");
    printf("Block No\tBlock Size\n");
    int freeFlag = 0;
    for (i = 0; i < nb; i++) {
        if (blockFlag[i] == 0) {
            printf("%d\t\t%d\n", i + 1, blockSize[i]);
            freeFlag = 1;
        }
    }
    if (!freeFlag)
        printf("None (All blocks allocated)\n");

    return 0;
}



/*
Problem Statement 11: Page Replacement – FIFO
Write a program to simulate the First In First Out (FIFO) page replacement algorithm.
The program should accept a page reference string and number of frames as input,
simulate the process of page replacement, and display the total number of page faults.
*/

#include <stdio.h>

int main() {
    int n, f, i, j, k = 0, flag, pageFaults = 0;

    printf("Enter the number of pages: ");
    scanf("%d", &n);

    int pages[n];
    printf("Enter the page reference string:\n");
    for (i = 0; i < n; i++) {
        scanf("%d", &pages[i]);
    }

    printf("Enter the number of frames: ");
    scanf("%d", &f);

    int frames[f];
    for (i = 0; i < f; i++)
        frames[i] = -1;  // initialize all frames as empty

    printf("\nPage Reference\tFrames\n");

    for (i = 0; i < n; i++) {
        flag = 0;

        // Check if page already exists in frame
        for (j = 0; j < f; j++) {
            if (frames[j] == pages[i]) {
                flag = 1; // page hit
                break;
            }
        }

        // Page fault occurs if not found
        if (flag == 0) {
            frames[k] = pages[i];  // replace the oldest page
            k = (k + 1) % f;       // circular queue
            pageFaults++;
        }

        // Display the current frame contents
        printf("%d\t\t", pages[i]);
        for (j = 0; j < f; j++) {
            if (frames[j] == -1)
                printf(" - ");
            else
                printf("%d ", frames[j]);
        }
        printf("\n");
    }

    printf("\nTotal Page Faults = %d\n", pageFaults);
    return 0;
}



/*
Problem Statement 12: Page Replacement – LRU
Write a program to simulate the Least Recently Used (LRU) page replacement algorithm.
The program should display the frame contents after each page reference and the total number of page faults.
*/
#include <stdio.h>

int findLRU(int time[], int n) {
    int i, min = time[0], pos = 0;
    for (i = 1; i < n; ++i) {
        if (time[i] < min) {
            min = time[i];
            pos = i;
        }
    }
    return pos;
}

int main() {
    int frames[10], pages[30], time[10];
    int n, f, counter = 0, faults = 0, flag1, flag2, i, j, pos;

    printf("Enter number of pages: ");
    scanf("%d", &n);
    printf("Enter the page reference string:\n");
    for (i = 0; i < n; ++i)
        scanf("%d", &pages[i]);

    printf("Enter number of frames: ");
    scanf("%d", &f);

    for (i = 0; i < f; ++i)
        frames[i] = -1; // initialize all frames empty

    printf("\nPage Reference\tFrames\n");

    for (i = 0; i < n; ++i) {
        flag1 = flag2 = 0;

        // Check if page already exists in frame
        for (j = 0; j < f; ++j) {
            if (frames[j] == pages[i]) {
                counter++;
                time[j] = counter;
                flag1 = flag2 = 1;
                break;
            }
        }

        // Empty frame available
        if (flag1 == 0) {
            for (j = 0; j < f; ++j) {
                if (frames[j] == -1) {
                    counter++;
                    faults++;
                    frames[j] = pages[i];
                    time[j] = counter;
                    flag2 = 1;
                    break;
                }
            }
        }

        // Replace least recently used page
        if (flag2 == 0) {
            pos = findLRU(time, f);
            counter++;
            faults++;
            frames[pos] = pages[i];
            time[pos] = counter;
        }

        // Print current state of frames
        printf("%d\t\t", pages[i]);
        for (j = 0; j < f; ++j) {
            if (frames[j] == -1)
                printf(" - ");
            else
                printf("%d ", frames[j]);
        }
        printf("\n");
    }

    printf("\nTotal Page Faults = %d\n", faults);
    return 0;
}

/*
Problem Statement 13: Page Replacement – Optimal
Write a program to simulate the Optimal Page Replacement algorithm.
The program should replace the page that will not be used for the longest period of time in the future and display the page replacement steps and page fault count.
*/

#include <stdio.h>

int findOptimal(int pages[], int frames[], int n, int index, int f) {
    int farthest = index, pos = -1;
    int i, j, found;

    for (i = 0; i < f; i++) {
        found = 0;
        for (j = index; j < n; j++) {
            if (frames[i] == pages[j]) {
                found = 1;
                if (j > farthest) {
                    farthest = j;
                    pos = i;
                }
                break;
            }
        }
        // If page is never used again, replace it immediately
        if (found == 0)
            return i;
    }

    // If all pages are used again, replace the farthest one
    return (pos == -1) ? 0 : pos;
}

int main() {
    int n, f, i, j, k, flag, faults = 0, pos;

    printf("Enter the number of pages: ");
    scanf("%d", &n);

    int pages[n];
    printf("Enter the page reference string:\n");
    for (i = 0; i < n; i++)
        scanf("%d", &pages[i]);

    printf("Enter the number of frames: ");
    scanf("%d", &f);

    int frames[f];
    for (i = 0; i < f; i++)
        frames[i] = -1;

    printf("\nPage Reference\tFrames\n");

    for (i = 0; i < n; i++) {
        flag = 0;

        // Check if page already exists in a frame
        for (j = 0; j < f; j++) {
            if (frames[j] == pages[i]) {
                flag = 1;
                break;
            }
        }

        // If page fault occurs
        if (flag == 0) {
            if (i < f) {
                frames[i] = pages[i];
            } else {
                pos = findOptimal(pages, frames, n, i + 1, f);
                frames[pos] = pages[i];
            }
            faults++;
        }

        // Print current frame status
        printf("%d\t\t", pages[i]);
        for (j = 0; j < f; j++) {
            if (frames[j] == -1)
                printf(" - ");
            else
                printf("%d ", frames[j]);
        }
        printf("\n");
    }

    printf("\nTotal Page Faults = %d\n", faults);
    return 0;
}


